Java代码命名规范
=

原因：

* 软件整个生命周期都几乎都是处于维护阶段
* 软件整个生命周期很难是同一个人员在维护
* 规范性的代码与命名增强了代码可读性，有助于工程师更快更高效掌控项目工程
* 规范性的代码与命名有利于成员之间的沟通，更清晰的业务与技术概念的定义，没有变体术语，没有近似术语，所有应用代码对所有团队都有相同意义。

接下来，依据官方编码命名再结合项目实践，针对以下两点做一些具体的详述

1. 源码文件组织
2. 命名规范

### 源码文件组织

Java源码文件（类、接口、枚举）以及其内代码语句规范

#### 类文件大小

通常，一个类文件具有太多代码行，比如大于1000行，即使是有一个好的编码组织，也可能变得异常笨重而难以维护，所以，尽可能避免它，当遇到大的类文件，尽量进行代码行的拆分，尽管有时因较强关联性而不好划分。

#### 类方法大小

同样，也需要注意类方法的大小控制，方法体牵涉过多的逻辑模块，太多的处理过程，导致程序易于出错，且不好调试，也不好阅读及后续的代码维护，

#### 访问控制修饰符

访问控制修饰符，决定了其它类是否能够使用其特定的属性，调用某一方法。 有两层级的访问控制：

* 包类修饰（*top-level*:public），或者 *package-level*（无明确修饰符）
* 成员修饰（*member-level*:public），private、protected，或者*package-private*（无明确修饰符）

一个class若被public修饰，其对所有包类可见，如果一个class未被修饰符修饰即package-level，其仅在自身包类可见

成员修饰级别，可以使用member-public或者package-private秀水，其可访问性如同包类修饰top-level及package-level，
其还有两个特有的访问控制修饰符：private、protected，被private修饰的成员仅类内成员可见，被protected修饰的成员自身包类及子类可见

可参考[官方](https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html )，总结以下列表访问控制矩阵：

| Modifier | Class | Package | Subclass | World |
| --- | --- | --- | --- | --- |
| public | Y | Y | Y | Y |
| protected | Y | Y | Y | N |
| *non* | Y | Y | N | N |
| private | Y | N | N | N |

第一列，类自身可访问性，从上图可知，类总会有自身成员可访问性；
第二列，包内类可访问性控制；
第三列，包内子类可访问性控制；
第四列，所有类可访问性控制。

#### 上层注释

即对类，接口，枚举，其注释规范 建议

* 不建议@author注解的使用，代码通常在开发人员之间共享，代码占用不是一个好习惯，对于代码变更，可通过版本控制追溯
* 不建议无意义的注释，尽可能通过规范命名代替注释，保持简洁易读
* 建议仅注释到接口定义，实现类会继承接口注释
* 建议使用母语注释，尽量避免使用蹩脚第二语言，以免词不达意

#### 类组织

类组织，这里指的是类及成员修饰符定义顺序上的规范

尽量使用package-level修饰符，除非你有足够的理由使用top-level修饰符

各类成员基本修饰属性：public, protected, package-level, private
类成员间划分定义顺序：
1. 静态属性
2. 静态语句块
3. 静态方法
4. 实例初始化语句块
5. 实例属性
6. 构造方法
7. 实例方法

    1. 通常顺序 : public, protected, package-level, private
    2. 也可按功能或责任组织
        
    结合多种方式是很好的实践，但要强调的是：风格要统一，要使用同样方式对待不同的类及成员，理想情况下是所有的开发成员能够达到风格统一。

8. 内部类
    
    可位于外部类顶端、外部类底部、外部类使用者成员上方

其它：

abstract static final transient volatile synchronized native


### 命名规范

Java编码中声名了很多东西：包，接口，抽象类，类，类的实例，方法，变量等，通过有意义的命名能够构建开发成员间易于沟通的桥梁，通过有意义的命名，大多数开发人员能够一般地理解任何大量的源代码。为团队节省了宝贵的时间。

#### 包命名

* 不要使用大写字母

    官方说明: package names are written in all lower case to avoid conflict with the names of classes or interfaces.

* 在一个应用中使用相同的包前缀
    
    应用编码中，所有类组件源码都必须是某一程序包的子代，达到能够通过包名即可猜出源码出处及作用，通过包名达到一种类别的划分，因为所有类必须与一种类别相关联，以便赋予它更多的意义。 例如，在JDK类中，List类或System类不直接在java包中，而位于位于java.lang包中
 
* 对于maven工程项目，建议包名前缀能与maven groupId相匹配
* 避免包命名太长
* 避免包层级太多

    建议5-6级即可
    
#### 变量命名

首字母缩写的驼峰样式，不建议使用下划线'_'及美元符号'$'

* 不要使用黑盒变量名

    a、x、 myVar、... 不知所谓何意，像是加密的命名
    
* 避免命名太泛意

    没有禁止使用的var、tmp、old、prev、next、actual、test、... 但建议使用其作为命名前缀，通过有意义的命名准确获知其上下文信息，比如：tmpAccess、prevPage、nextCursor、...

#### 类型命名 (class, interface, enum)

首字母大写的驼峰样式，名字应该使用名词或名词短语，禁止使用动词和动词组合

* 非抽象类型避免命名太泛意

    比如，定义一个Type类，在特定语境中意有所指，但全局语境中，意表不明，容易引起歧义，混乱。因此，命名要明确所指，在特定上下文中，根据其语境，可使用前缀或者后缀加以判别

* 若有可能，避免命名太长

    因为，太长的话，难读，难写，IDE环境中难索引不易于检索
    
* 通用意义的命名中可使用简短前缀或后缀，深表其用意

    比如，XxxServiceImpl，Service指明接口定义，ServiceImpl指明接口实现
    
#### 方法命名
    
首字母缩写的驼峰样式，名字应该使用动词或动宾短语组合，禁止使用名词或其它非动词

* 命名必须能够表明要做什么

    与类型命名或变量命名规范要求相反，方法命名规范要求，不必害怕有个长的命名，合适长度的命名可以更深意的表明所做之事，比如更改用户姓名方法saveUser(User user) 可以更深一步定义为saveUserWithName（User user），但也不是越长越好，比如，saveUserWithNameAndAddressAndAgeAndContract(User user)，显然，很别扭，不稳固，不好读，混乱，难以维护，之所以难以维护，是因为，任何的逻辑改动，都有可能牵涉到命名上的歧义，甚者方法命名的频繁调整，使用saveUserWithRelatedData(User user)是一个较好的替代
    
#### 枚举命名

枚举命名规范如同类名命名，枚举集合元素命名，全大写字母，结合下划线易其阅读，要求使用全名词组合

#### 常量命名

常量命名方式有很多种，但命名规范上也必须如同枚举：全大写字母，结合下划线易其阅读，要求使用全名词组合

* 建议不要定义过多常量类

    尤其是指 ，一个常量类通常仅含有一种或少有几种常量类型，若过多时，可以使用静态内部类进行重构。
    
* 依据常量类型，定义适当的命名前缀

#### 注解

注解命名规范：功能性修饰名词组合[adjective|verb][noun]

Ex.g.

    @Documented
    @Retention(RetentionPolicy.RUNTIME)
    @Target(ElementType.TYPE)
    public @interface FunctionalInterface {}

